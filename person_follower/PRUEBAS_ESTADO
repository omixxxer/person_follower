import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
import numpy as np
import time

class PersonFollower(Node):
    def __init__(self):
        super().__init__('person_follower')
        self.publisher_ = self.create_publisher(Twist, '/cmd_vel', 10)
        self.subscription = self.create_subscription(
            LaserScan,
            '/scan',
            self.listener_callback,
            10)
        self.state = "reposo"  # Estado inicial
        self.prev_angles = []  # Almacena ángulos anteriores para suavizado
        self.angle_filter_window = 5  # Tamaño de la ventana para el suavizado de ángulos
        self.min_distance = 0.5  # Distancia mínima para evitar colisiones
        self.follow_threshold = 1.0  # Rango de detección durante el seguimiento
        self.follow_angle_range = 75  # Rango de ángulo de detección durante el seguimiento
        self.stop_timer_threshold = 5  # Umbral de tiempo para considerar que el robot está parado
        self.stop_timer = 0  # Temporizador para contar el tiempo que el robot está parado

    def detect_person(self, ranges, angle_min, angle_increment):
        ranges_np = np.array(ranges)  # Convertir rangos a un array de NumPy
        angles = np.arange(angle_min, angle_min + len(ranges_np) * angle_increment, angle_increment)
        x = np.multiply(ranges_np, np.cos(angles))
        y = np.multiply(ranges_np, np.sin(angles))

        # Filtrar puntos fuera de un rango y ángulo razonables
        valid_indices = np.where((ranges_np < self.follow_threshold) & (angles >= -self.follow_angle_range/2) & (angles <= self.follow_angle_range/2))

        if len(valid_indices[0]) > 0:
            # Calcular el centroide de los puntos válidos
            centroid_x = np.mean(x[valid_indices])
            centroid_y = np.mean(y[valid_indices])

            # Determinar si hay una persona presente basada en la ubicación del centroide
            if np.sqrt(centroid_x ** 2 + centroid_y ** 2) < self.follow_threshold:
                self.get_logger().info("¡Persona detectada!")
                return True

        return False

    def smooth_angle(self, angle):
        # Lógica para suavizar el ángulo
        self.prev_angles.append(angle)
        if len(self.prev_angles) > self.angle_filter_window:
            self.prev_angles.pop(0)
        return sum(self.prev_angles) / len(self.prev_angles)

    def change_state(self, new_state):
        # Cambiar el estado del robot
        self.get_logger().info("Cambiando estado a: {}".format(new_state))
        self.state = new_state

    def listener_callback(self, input_msg):
        angle_min = input_msg.angle_min
        angle_increment = input_msg.angle_increment
        ranges = input_msg.ranges

        if self.state == "reposo":
            # En estado de reposo, no hacer nada
            return

        if self.state == "busqueda":
            # Realizar una búsqueda de 360 grados
            if self.detect_person(ranges, angle_min, angle_increment):
                # Si se detecta a una persona, cambiar al estado de seguimiento
                self.change_state("seguimiento")
                self.stop_timer = 0  # Reiniciar el temporizador de parada
            else:
                # Realizar una búsqueda completa girando en el lugar
                output_msg = Twist()
                output_msg.angular.z = 0.5  # Velocidad angular para girar
                self.publisher_.publish(output_msg)

                # Incrementar el temporizador si el robot está parado
                if min(ranges) < self.min_distance:
                    self.stop_timer += 1
                    if self.stop_timer > self.stop_timer_threshold:
                        self.change_state("reposo")
                        self.get_logger().info("Objeto detectado por mucho tiempo. Cambiando al estado de reposo.")
                        # Girar 180 grados para intentar salir del obstáculo
                        self.rotate_180_degrees()
            return

        if self.state == "seguimiento":
            # Estado de seguimiento: seguir a la persona detectada
            if self.detect_person(ranges, angle_min, angle_increment):
                min_range_index = np.argmin(ranges)
                angle_to_person = angle_min + min_range_index * angle_increment
                if self.prev_angles:
                    angle_to_person = self.smooth_angle(angle_to_person)

                if min(ranges) < self.min_distance:
                    vx = 0.05  # Velocidad reducida
                else:
                    vx = 0.35  # Velocidad normal

                target_angle = angle_to_person
                angle_difference = -target_angle  # Cambio de orientación para moverse

                max_angular_velocity = 0.6
                if abs(angle_difference) > max_angular_velocity:
                    angle_difference = max_angular_velocity if angle_difference > 0 else -max_angular_velocity

                wz = 2.0 * angle_difference

                output_msg = Twist()
                output_msg.linear.x = vx
                output_msg.angular.z = wz
                self.publisher_.publish(output_msg)

                # Mostrar información sobre el ángulo que se sigue
                self.get_logger().info("Siguiendo ángulo: {:.2f}".format(angle_to_person))
            else:
                # Si la persona ya no se detecta, volver al estado de búsqueda
                self.change_state("busqueda")
            return

    def rotate_180_degrees(self):
        output_msg = Twist()
        output_msg.angular.z = 0.5  # Velocidad angular para girar
        start_time = time.time()
        while time.time() - start_time < 3.0:  # Girar durante aproximadamente 3 segundos para simular 180 grados
            self.publisher_.publish(output_msg)

def main(args=None):
    rclpy.init(args=args)
    person_follower = PersonFollower()

    # Cambiar al estado de reposo inicialmente
    person_follower.change_state("reposo")

    # Después de un tiempo, cambiar al estado de búsqueda
    person_follower.get_logger().info("Iniciando búsqueda...")
    person_follower.change_state("busqueda")

    rclpy.spin(person_follower)
    person_follower.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
